## ΑΡΧΙΤΕΚΤΟΝΙΚΗ ΠΡΟΗΓΜΕΝΩΝ ΥΠΟΛΟΓΙΣΤΩΝ

### 1η Εργαστηριακή Άσκηση
#### Εισαγωγή στον Εξομοιωτή gem5

**1.** Η εντολή που χρησιμοποιήσαμε για να τρέξουμε το precompiled πρόγραμμα _hello_ είναι η 

>$ ./build/ARM/gem5.opt configs/example/arm/starter_se.py --cpu="minor" "tests/test-progs/hello/bin/arm/linux/hello"

Σε αυτήν φαίνεται ότι δηλώνεται ρητά η χρήση του μοντέλου MinorCPU, με το argument **--cpu="minor"**, και ότι το πρόγραμμα που θα εκτελεστεί είναι το _hello_, δίνοντας το path **"tests/test-progs/hello/bin/arm/linux/hello"**.

Ανοίγοντας, τώρα, το αρχείο *starter_se.py*, μπορούμε να δούμε τα χαρακτηριστικά του συστήματος που γίνεται emulated (στην πραγματικότητα, εφόσον δουλεύουμε στην λειτουργία System Call Emulation, δεν πραγματοποιείται προσομοίωση του πλήρους συστήματος, αλλά μόνο του επεξεργαστή και του υποσυστήματος μνήμης). 

Συγκεκριμένα, στην συνάρτηση **main** φαίνονται τα arguments που περνάνε για την δημιουργία του συστήματος.

* **commands\_to\_run** (_οι εντολές που πρόκειται να εκτελεστούν_): - 
* **--cpu** (_το μοντέλο CPU που χρησιμοποιείται_): ως default χρησιμοποιείται το μοντέλο Atomic, με την εντολή όμως που χρησιμοποιήσαμε, επιλέξαμε το μοντέλο **Minor**
* **--cpu-freq** (_η συχνότητα του επεξεργαστή_): **4GHz** (default) 
* **--num-cores** (_ο αριθμός των πυρήνων του επεξεργαστή_): **1** (default)
* **--mem-type** (_ο τύπος της μνήμης που χρησιμοποιείται_): **DDR3 1600MHz 8x8GB** (default)
* **--mem-channels** (_ο αριθμός των καναλιών μνήμης_): **2** (default)
* **--mem-ranks** (_ο αριθμός των κατηγοριών μνήμης ανά κανάλι_): -
* **--mem-size** (_το μέγεθος της φυσικής μνήμης_): **2GB** (default)  

Επίσης, στην συνάρτηση **\_\_init__** γίνεται η δημιουργία του clock και του voltage domain. Εκεί θέτουμε την συχνότητα του clock domain στο **1GHz** και την τάση του voltage domain στα **3.3 Volt**.  Στην ίδια συνάρτηση, ορίζουμε την τάση του CPU cluster στο **1.2 Volt** και το memory mode στο **timing**.
Όσον αφορά την μνήμη cache, εφόσον χρησιμοποιήσαμε το μοντέλο MinorCPU, έχουμε την **L1 Cache** και την **L2 Cache**, κάτι που φαίνεται από τα Lines 67 και 69.

**2.** **a.** Από το αρχείο config.ini μπορούμε να εξάγουμε τις εξής πληροφορίες για το σύστημα:  

* Line 20: **mem_mode = timing** (_η λειτουργία της μνήμης_)
* Line 44: **clock = 1000**, το οποίο αντιστοιχεί σε **1GHz** (_η συχνότητα του clock domain_)
* Line 58: **clock = 250**, το οποίο αντιστοιχεί σε **4GHz** (_η συχνότητα του επεξεργαστή_)
* Line 65:  **type = MinorCPU** (_το μοντέλο CPU που χρησιμοποιείται_)
* Line 113: **numThreads = 1** (_ο αριθμός των πυρήνων του επεξεργαστή_)
* Line 1339: **voltage=1.2** (_η τάση του CPU cluster_)
* Line 1349 και Line 1479:  **system.mem\_ctrls0** και **system.mem\_ctrls1**, άρα **2** (_ο αριθμός των καναλιών μνήμης_) 
* Line 1376: **type = DRAMInterface** (_ο τύπος της μνήμης που χρησιμοποιείται_)
* Line 1652: **voltage = 3.3** (_η τάση του voltage domain_)

**b.** Από το stats.txt, βλέπουμε στο Line 14 ότι το συνολικό νούμερο των commited εντολών είναι **5028**. Ο λόγος που ο αριθμός αυτός διαφέρει από τον αριθμό των committed διαδικασιών που εκτελούνται, ο οποίος φαίνεται στο Line 15: **system.cpu_cluster.cpus.committedOps=5834**, είναι επειδή αυτός αφορά και ορισμένες επιπλέον εντολές, που σχετίζονται με το να τεθούν σε λειτουργία οι registers του προσομοιωμένου συστήματος κτλ.  

**c.** Από το stats.txt, βλέπουμε στο Line 493 ότι η L2 προσπελάστηκε **479** φορές. Χωρίς την βοήθεια του εξομοιωτή, θα μπορούσαμε να υπολογίσουμε τον αριθμό των φορών που προσπελάστηκε η L2 ξέροντας το miss rate της L1, οπότε και θα υπολογίζαμε τον όρο 1-(miss rate της L1), εφόσον κατά κανόνα όταν δεν βρίσκεται το επιθυμητό word στην L1 cache, γίνεται αναζήτησή του στην L2 cache.

**3.** Τα in-order μοντέλα CPU που χρησιμοποιούνται από τον gem5 είναι:

* **Simple CPU**: Η κατηγορία SimpleCPU έχει να κάνει με μια αφηρημένη δομή επεξεργαστή η οποία δεν περιλαμβάνει pipelining, πράγμα που την καθιστά μη ρεαλιστική. Αυτό βέβαια έχει ως αποτέλεσμα ο επεξεργαστής να τρέχει πολύ γρήγορα, γι'αυτούς τους λόγους συνήθως χρησιμοποιούνται για την εκκίνηση των Linux, ώσπου στη συνέχεια γίνεται μετάβαση σε ένα πιο λεπτομερές μοντέλο επεξεργαστή.  
	* **BaseSimpleCPU**: Η κατηγορία BaseSimpleCPU δεν μπορεί να λειτουργήσει από μόνη της και χρειάζεται να δανειστεί λειτουργικότητα από τις AtomicSimpleCPU ή TimingSimpleCPU. Μπορεί να οδηγήσει το program counter στην επόμενη εντολή, ορίζει συναρτήσεις που ελέγχουν για interrupts, και διαχειρίζεται τις ρυθμίσεις και τις λειτουργίες πριν και μετά την εκτέλεση κάποιας εντολής. Εφαρμόζει την ExecContext διεπαφή.
	* **AtomicSimpleCPU**: Αναλαμβάνει και εκτελεί τα αιτήματα που ζητούν πρόσβαση στη μνήμη άμεσα.
	* **Timing SimpleCPU**: Η κάθε αίτηση μεταβαίνει στο σύστημα μνήμης και επιστρέφει, όμως λόγω απουσίας pipelining, έχουμε ως αποτέλεσμα σε κάθε τέτοιο request να καθυστερεί, αναμένοντας το αντίστοιχο response.

* **Minor CPU**:  Η κατηγορία MinorCPU είναι ένα μοντέλο επεξεργαστή στο οποίο εμφανίζεται pipelining τεσσάρων σταδίων, που ακολουθεί έναν μη προγραμματιζόμενο τρόπο λειτουργίας, αλλά δίνει την δυνατότητα επεξεργασίας των δομών δεδομένων και του τρόπου εκτέλεσης τους. Σχεδιάστηκε ώστε να προσομοιώνει αυστηρά in-order επεξεργαστές και έτσι καταφέρνει να απεικονίσει την τοποθεσία μιας εντολής εντός του pipeline.

**a.** Το πρόγραμμα που γράφτηκε σε C είναι ένας απλός υπολογισμός των αριθμών Fibonacci, για τους πρώτους 10 αριθμούς. Κατά την εκτέλεσή του χρησιμοποιήθηκαν τα μοντέλα TimingSimpleCPU και MinorCPU. Από τα stats.txt, εξάγαμε τις εξής πληροφορίες για τους χρόνους εκτέλεσης:

* **TimingSimpleCPU**: Line 12 του stats.txt: **sim\_seconds = 0.000048** (_δευτερόλεπτα που περνούν μέσα στην προσομοίωση για την εκτέλεση του προγράμματος_) 
* **MinorCPU**: Line 12 του stats.txt: **sim\_seconds = 0.000039**

**b.** Οι διαφορές στους παραπάνω χρόνους εκτέλεσης έγκεινται στο ότι, στην περίπτωση του MinorCPU, μπορούμε να εκμεταλλευτούμε το pipelining για ταχύτερη εκτέλεση εντολών.

**c.** Χρησιμοποιώντας το μοντέλο MinorCPU, αλλάξαμε την συχνότητα λειτουργίας του συστήματος στα **2GHz**, με το flag --sys-clock=2000000000. Τα αποτελέσματα (stats.txt) μας έδειξαν μικρότερο χρόνο εκτέλεσης (Line 12: **sim\_seconds=0.000036**), κάτι που είναι αναμενόμενο εφόσον αυξήσαμε την συχνότητα λειτουργίας. Έπειτα, αλλάξαμε το μοντέλο μνήμης που χρησιμοποιείται σε DDR4 2400MHz 8x8, με το flag --mem-type=DDR4_2400_8x8. Τα αποτελέσματα μας έδειξαν για ακόμη μία φορά μικρότερο χρόνο εκτέλεσης (αν και όχι κατά πολύ: Line 12: **sim\_seconds=0.000038**), πράγμα που δικαιολογείται από το γεγονός ότι το μοντέλο DDR4 παρουσιάζει ταχύτερο data transfer speed.

Χρησιμοποιώντας, τώρα, το μοντέλο TimingSimpleCPU, αλλάζοντας την συχνότητα του συστήματος στα **500MHz**, με το flag --sys-clock=500000000, είδαμε μεγαλύτερο χρόνο εκτέλεσης συγκριτικά με το 1GHz (Line 12: **sim\_seconds=0.000054**), εφόσον μειώσαμε την συχνότητα. Με την αλλαγή του μοντέλου μνήμης σε DDR3 2133MHz 8x8, είδαμε μείωση του χρόνου εκτέλεσης σε **sim\_seconds=0.000047**, πράγμα αναμενόμενο εφόσον αυξήσαμε την συχνότητα, από 1600MHz, σε 2133MHz.

### ΠΗΓΕΣ

Οι πηγές από τις οποίες αντλήσαμε πληροφορίες είναι:

1. [http://learning.gem5.org/book/part1/simple_config.html](http://learning.gem5.org/book/part1/simple_config.html)
2. [http://learning.gem5.org/book/part1/gem5_stats.html](http://learning.gem5.org/book/part1/gem5_stats.html)
3. [http://www.gem5.org/documentation/general_docs/cpu_models/SimpleCPU](http://www.gem5.org/documentation/general_docs/cpu_models/SimpleCPU)
4. [http://www.gem5.org/documentation/general_docs/cpu_models/minor_cpu](http://www.gem5.org/documentation/general_docs/cpu_models/minor_cpu)
5. [https://cirosantilli.com/linux-kernel-module-cheat/#gem5-cpu-types](https://cirosantilli.com/linux-kernel-module-cheat/#gem5-cpu-types)
6. [https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips](https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips)
7. [https://www.atpinc.com/blog/ddr4-vs-ddr3-differences-advantages](https://www.atpinc.com/blog/ddr4-vs-ddr3-differences-advantages)

***

### ΚΡΙΤΙΚΗ
Το πρώτο εργαστήριο ήταν αρκετά εισαγωγικό. Το PDF που δόθηκε ήταν πολύ βοηθητικό, με λεπτομερείς οδηγίες για την εγκατάσταση των απαραιτήτων. Υπήρχαν, ωστόσο, ορισμένα λάθη σε κάποιες εντολές, όπως στην:
>$ ./build/ARM/gem5.opt configs/example/se.py --cpu=MinorCPU –caches
tests/test-progs/hello/bin/arm/linux/hello

όπου το σωστό flag είναι το --cpu-type=MinorCPU. Επιπλέον, η συμβουλή να γίνει το build του gem5 χρησιμοποιώντας τον αριθμό των επεξεργαστών που έχει ο υπολογιστής μας αποδείχθηκε μοιραία, καθώς διακοπτόταν η διαδικασία μετά από αρκετή ώρα, χωρίς να ξέρουμε ακριβώς τον λόγο. Με μικρότερο Ν (πχ 2), το build έγινε κανονικά.

Ο πειραματισμός και η εξοικείωση με τα αρχεία starter_se.py, stats.txt και config.ini βοήθησαν πολύ στο να αποκτήσουμε καλή εικόνα για τον gem5 και την προσομοίωση του συστήματος.


